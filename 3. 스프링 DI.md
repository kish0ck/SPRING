# Chapter 3 스프링 DI

- 이 장에서 다룰 내용
  - 객체 의존과 의존 주입(DI)
  - 객체 조립
  - 스프링 DI 설정



1. ### **의존이란?**

- DI는 'Dependency Injection'의 약자로 우리말로는 '의존 주입'이라고 번역한다.
- 의존(dependency)이란 객체 간의 의존을 의미



ex) 회원가입 처리 기능

```java
package spring;

import java.time.LocalDateTime;

public class MemberRegisterService {
	private MemberDao memberDao;

	public void regist(RegisterRequest req) {
		// 이메일로 회원 데이터(Member) 조회
		Member member = memberDao.selectByEmail(req.getEmail());
		if (member != null) {
			// 같은 이메일을 가진 회원이 이미 존재하면 익셉션 발생
			throw new DuplicateMemberException("dup email " + req.getEmail());
		}
		// 같은 이메일을 가진 회원이 존재하지 않으면 DB에 삽입
		Member newMember = new Member(
				req.getEmail(), req.getPassword(), req.getName(), 
				LocalDateTime.now());
		memberDao.insert(newMember);
	}
}
```

-> 서로 다른 회원은 동일한 이메일 주소를 사용할 수 없다는 요구사항

이 제약사항을 처리하기 위해 MembeRegisterService 클래스는 MemberDao 객체의 selectByEmail() 메서드를 이용해서 동일한 이메일을 가진 회원 데이터가 존재하는지 확인한다.

만약 같은 이메일을 가진 회원 데이터가 존재한다면 위 코드처럼 익셉션을 발생시킨다.

같은 이메일을 가진 회원 데이터가 존재하지 않으면 회원 정보를 담은 Member 객체를 생성하고 MemberDao 객체의 insert() 메서드를 이용해서 DB에 회원 데이터를 삽입한다.



위 코드에서 눈여겨볼 점은 MemberRergisterServiece 클래스가 DB 처리를 위해 MemberDao 클래스의 메서드를 사용한다는 점. 회원 데이터가 존재하는지 확인하기 위해 MemberDao 객체의 selectByEmail() 메서드를 실행하고, 회원 데이터를 Db에 삽입하기위해 insert() 메서드를 실행



이렇게 한 클래스가 다른 클래스의 메서드를 실행할 때 이를 ***'의존'*** 한다고 표현한다. 앞서 코드에서는 "MemberRegisterService" 클래스가 MemberDao 클래스에 의존한다고 표현할 수 있다.



의존하는 대상이 있으면 그 대상을 구하는 방법이 필요하다. 가장 쉬운 방법은 의존 대상객체를 직접 생성하는 것이다. 앞서 살펴본 MemberRegisterService 클래스도 다음 코드처럼 의존 대상인 MemberDao의 객체를 직접 생성해서 필드에 할당했다.



의존하는 대상이 있으면 그 대상을 구하는 방법이 필요하다. 가장 쉬운 방법은 의존 대상 객체를 직접 생성하는 것이다. 앞서 살펴본 MemberRegisterService 클래스도 다음 코드처럼 의존 대상인 MemberDao의 객체를 직접 생성해서 필드에 할당했다.

```java
public class MemberRegisterService {
	// 의존 객체를 직접 생성
	private MemberDao memberDao = new MemberDao();
	...
}
```



MemberRegisterService 클래스에서 의존하는 MemberDao 객체를 직접 생성하기 때문에 MemberRegisterService 객체를 생성하는 순간에 MemberDao 객체도 함께 생성한다.

```java
// 의존하는 memberDao의 객체도 함께 생성
MemberRegisterService svc = new MemberRegisterService();
```

클래스 내부에서 직접 의존 객체를 생성하는 것이 쉽긴하지만 유지보수 관점에서 문제점을 유발할 수 있다. 이 방식 외에 의존 객체를 구하는 또 다른 방법은 DI와 서비스 로케이터가 있다.





2. ### DI를 통한 의존 처리

- DI(Dependency Injection, 의존 주입)는 의존하는 객체를 직접 생성하는 대신 의존 객체를 전달받는 방식을 사용한다. 예를 들어 앞서 의존 객체를 직접 생성한 MemberRegisterService 클래스에 DI 방식을 적용하면 아래 코드 처럼 구현할 수 있다.

```java
package spring;

import java.time.LocalDateTime;

public class MemberRegisterService {
	private MemberDao memberDao;

	public MemberRegisterService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}

	public Long regist(RegisterRequest req) {
		Member member = memberDao.selectByEmail(req.getEmail());
		if (member != null) {
			throw new DuplicateMemberException("dup email " + req.getEmail());
		}
		Member newMember = new Member(
				req.getEmail(), req.getPassword(), req.getName(), 
				LocalDateTime.now());
		memberDao.insert(newMember);
		return newMember.getId();
	}
}

```

바뀐 부분은

 ```
public MemberRegisterService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}
 ```

이 부분이다. 직접 의존 객체를 생성했던 코드와 달리 바뀐 코드는 의존 객체를 직접 생성하지 않는다. 대신 08 ~ 10행과 같이 생성자를 통해서 의존 객체를 전달받는다. 즉 생성자를 통해 MemberRegisterService가 의존(Dependency)하고 있는 MemberDao 객체를 주입받은 것이다. 의존 객체를 직접 구하지 않고 생성자를 통해서 전달받기 때문에 이 코드는 DI패턴을 따르고 있다.



DI를 적용한 결과 MemberRegisterService 클래스를 사용하는 코드는 다음과 같이 MemberRegisterService 객체를 생성할 때 생성자에 MemberDAo 객체를 전달해야 한다.

```java
MemberDao dao = new MemberDao();
// 의존 객체를 생성자를 통해 주입한다.
MemberRegisterService svc = new MemberRegisterService(dao);
```

직접 의존 객체를 생성하지 않고 굳이 생성자를 통해서 의존하는 객체를 주입하는 이유는? 객체 지향 설계에 대한기본적인 이해가 필요하다.  그 이유는 **변경의 유연함**이다.





3. ### DI와 의존 객체 변경의 유연함

   의존 객체를 직접 생성하는 방식은 필드나 생성자에서 new 연산자를 이용해서 객체를 생성한다.

   회원 등록 기능을 제공하는 MemberRegisterService 클래스에서 다음 코드처럼 의존 객체를 직접 생성할 수 있다. 

   ```java
   public class MemberRegisterService {
   	private MemberDao memberDao = new MemberDao();
   	...
   }
   ```

   회원의 암호 변경 기능을 제공하는 ChangePasswordService 클래스도 다음과 같이 의존 객체를 직접 생성

   ```java
   public class ChangePasswordService {
   	private MemberDao memberDao = new MemberDao();
   	...
   }
   ```

   MemberDao 클래스는 회원 데이터를 데이터베이스에 저장한다고 가정. 이 상태에서 회원 데이터의 빠른 조회를 위해 캐시를 적용해야 하는 상황이 발생. 그래서 MemberDao 클래스를 상속받은 CachedMemberDao 클래스를 만들었다.

   ```java
   public class CachedMemberDao extends MemberDao { 
   	...
   }
   ```



※ 캐시는 데이터 값을 복사해 놓는 임시 장소를 가리킨다. 보통 조회 속도 향상을 위해 캐시를 사용한다. 예를 들어 데이터베이스에서 데이터를 조회하는경우를 생각해보자. 데이터베이스에서 데이터를 읽어오는데 10 밀리초(1밀리 초는 0.001초)가 걸린다면 메모리에 있는 데이터를 접근할 때에는 1밀리초도 안걸릴 것이다. DB에 있는 데이터 중 자주 조회하는 데이터를 메모리를 사용하는 캐시에 보관하면 조회 속도를 향상시킬 수 있다.



​	캐시 기능을 적용한 CachedMemberDao를 사용하려면 MemberRegisterService 클래스와 ChangePasswordService 클래스의 코드를 아래와 같이 변경해주어야 한다.



```java
public class MemberRegisterService {
	private MemberDao memberDao = new MemberDao();
	...
}

public class ChangePasswordService {
	private MemberDao memberDao = new MemberDao();
	...
}
```

사용할 클래스 변경에 따른 소스 코드 변경

```java
public class MemberRegisterService {
	private MemberDao memberDao = new CachedMemberDao();
	...
}

public class ChangePasswordService {
	private MemberDao memberDao = new CachedMemberDao();
	...
}
```

만약 MemberDao 객체가 필요한 클래스가 세 개라면 세 클래스 모두 동일하게 소스 코드를 변경해야 한다.



동일한 상황에서 DI를 사용하면 수정할 코드가 줄어든다. 예를 들어 다음과 같이 생성자를 통해서 의존 객체를 주입 받도록 구현했다고 하자.

```java
public class MemberRegisterService {
	private MemberDao memberDao = new MemberDao();
	public MemberRegisterService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}
	...
}

public class ChangePasswordService {
	private MemberDao memberDao = new MemberDao();
	public ChangePasswordService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}
	...
}
```

두 클래스의 객체를 생성하는 코드는 다음과 같다

```java
MemberDao memberDao = new MemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

실제 객체를 생성하는 한 곳만 수정

```java
MemberDao memberDao = new CachedMemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

Di를 사용하면 MemberDao 객체를 사용하는 클래스가 세개여도 변경할 곳은 의존 주입 대상이 되는 객체를 생성하는 코드 한 곳 뿐이다. 앞서 의존 객체를 직접 생성했던 방식에 비해 변경할 코드가 한 곳으로 집중되는 것을 알 수 있다.



5. ### 객체 조립기

   앞서 DI를 설명할 때 객체 생성에 사용할 클래스를 변경하기 위해 (그 객체를 사용하는 코드를 변경하지 않고) 객체를 주입하는 코드 한 곳만 변경하면 된다고 했다. 그렇다면 실제 객체를 생성하는 코드는 어디에 있을까? *쉽게 생각하면 다음과 같이 메인 메서드에서 객체를 생성하면 될 것 같다.*

   ```java
   public class Main {
   	public static void main(String[] args) {
   		MemberDao memberDao = new MemberDao();
   		MemberRegisterService regSvc = new MemberRegisterService(memberDao);
           ChangePasswordService pwdSvc = new ChangePasswordService();
           pwdSvc.SetMemberDao(memberDao);
           ... // regSvc와 pwdSvc를 사용하는 코드
   	}
   }
   ```

   main 메서드에서 의존 대상 객체를 생성하고 주입하는 방법이 나쁘진 않다. 이방법보다 좀 더 나은 방법은 객체를 생성하고 의존 객체를 주입해주는 클래스를 따로 작성하는 것. 의존 객체를 주입한다는 것은 서로 다른 두 객체를 조립한다고 생각할 수 있는데 이런 의미에서 이 클래스를 조립기하고도 표현한다.



예를 들어 앞서 작성했던 회원 가입이나 암호 변경 기능을 제공하는 클래스의 객체를 생성하고 의존 대상이 되는 객체를 주입해주는 조립기 클래스는 아래와 같이 작성할 수 있다. 다른 클래스와 쉽게 구분하기 위해 조립기 클래스를 "assembler"패키지에 위치 시켰다.

```java
package assembler;

import spring.ChangePasswordService;
import spring.MemberDao;
import spring.MemberRegisterService;

public class Assembler {

	private MemberDao memberDao;
	private MemberRegisterService regSvc;
	private ChangePasswordService pwdSvc;

	public Assembler() {
		memberDao = new MemberDao();
		regSvc = new MemberRegisterService(memberDao);
		pwdSvc = new ChangePasswordService();
		pwdSvc.setMemberDao(memberDao);
	}

	public MemberDao getMemberDao() {
		return memberDao;
	}

	public MemberRegisterService getMemberRegisterService() {
		return regSvc;
	}

	public ChangePasswordService getChangePasswordService() {
		return pwdSvc;
	}

}
```

* regSvc : MemberRegisterService(memberDao 필드) + pwdSvc : ChangePasswordService(memberDao 필드) => memberDao : MemberDao(map 필드)



Assembler 클래스를 사용하는 코드는 다음처럼 Assembler 객체를 생성한다. 그 다음에 get 메서드를 이용해서 필요한 객체를 구하고 그 객체를 사용한다.

```java
Assembler assembler = new Assembler();
ChangePasswordService changePwdSvc = assembler.getChangePasswordService();
changePwdSvc.changePassword("madvirus@madvirus.net", "1234", "newpwd");
```



MemberDao 클래스가 아니라 MemberDao 클래스를 상속받은 CachedMemberDao 클래스를 사용해야 한다면 Assembler에서 객체를 초기화하는 코드만 변경하면 된다.

```java
public Assembler() {
	memberDao = new CachedMemberDao();
	regSvc = new MemberRegisterService(memberDao);
	pwdSvc = new ChangePasswordService();
	pwdSvc.setMemberDao(memberDao);
}
```


예제

```java
package main;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import assembler.Assembler;
import spring.ChangePasswordService;
import spring.DuplicateMemberException;
import spring.MemberNotFoundException;
import spring.MemberRegisterService;
import spring.RegisterRequest;
import spring.WrongIdPasswordException;

public class MainForAssembler {

	public static void main(String[] args) throws IOException {
		BufferedReader reader = 
				new BufferedReader(new InputStreamReader(System.in));
		while (true) {
			System.out.println("명령어를 입력하세요:");
			String command = reader.readLine();
			if (command.equalsIgnoreCase("exit")) {
				System.out.println("종료합니다.");
				break;
			}
			if (command.startsWith("new ")) {
				processNewCommand(command.split(" "));
				continue;
			} else if (command.startsWith("change ")) {
				processChangeCommand(command.split(" "));
				continue;
			}
			printHelp();
		}
	}

	private static Assembler assembler = new Assembler();

	private static void processNewCommand(String[] arg) {
		if (arg.length != 5) {
			printHelp();
			return;
		}
		MemberRegisterService regSvc = assembler.getMemberRegisterService();
		RegisterRequest req = new RegisterRequest();
		req.setEmail(arg[1]);
		req.setName(arg[2]);
		req.setPassword(arg[3]);
		req.setConfirmPassword(arg[4]);
		
		if (!req.isPasswordEqualToConfirmPassword()) {
			System.out.println("암호와 확인이 일치하지 않습니다.\n");
			return;
		}
		try {
			regSvc.regist(req);
			System.out.println("등록했습니다.\n");
		} catch (DuplicateMemberException e) {
			System.out.println("이미 존재하는 이메일입니다.\n");
		}
	}

	private static void processChangeCommand(String[] arg) {
		if (arg.length != 4) {
			printHelp();
			return;
		}
		ChangePasswordService changePwdSvc = 
				assembler.getChangePasswordService();
		try {
			changePwdSvc.changePassword(arg[1], arg[2], arg[3]);
			System.out.println("암호를 변경했습니다.\n");
		} catch (MemberNotFoundException e) {
			System.out.println("존재하지 않는 이메일입니다.\n");
		} catch (WrongIdPasswordException e) {
			System.out.println("이메일과 암호가 일치하지 않습니다.\n");
		}
	}

	private static void printHelp() {
		System.out.println();
		System.out.println("잘못된 명령입니다. 아래 명령어 사용법을 확인하세요.");
		System.out.println("명령어 사용법:");
		System.out.println("new 이메일 이름 암호 암호확인");
		System.out.println("change 이메일 현재비번 변경비번");
		System.out.println();
	}
}
```

6. ### 스프링의 DI 설정

- 스프링이 DI를 지원하는 조립기

- 스프링은 앞서 구현한 조립기와 유사한 기능을 제공

  즉, 스프링은 Assembler 클래스의 생성자 코드처럼 필요한 객체를 생성하고 생성한 객체에 의존을 주입한다.

  또한 스플링은 Assembler#getMemberRegisterService() 메서드처럼 객체를 제공하는 기능을 정의하고 있다.

  차이점이라면 ASsembler는 memberRegisterService나 MemberDao와 같이 특정 타입의 클래스만 생성한 반면 스프링은 범용 조립기라는 점



​	6-1. 스프링을 이용한 객체 조립과 사용

```java
package config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import spring.ChangePasswordService;
import spring.MemberDao;
import spring.MemberInfoPrinter;
import spring.MemberListPrinter;
import spring.MemberPrinter;
import spring.MemberRegisterService;
import spring.VersionPrinter;

// 스프링 설정 클래스를 의미
// 이 애노테이션을 붙여야 스프링 설정 클래스로 사용할 수 있다.
@Configuration
public class AppCtx {

	@Bean
	public MemberDao memberDao() {
		return new MemberDao();
	}
	
	@Bean
	public MemberRegisterService memberRegSvc() {
		return new MemberRegisterService(memberDao());
        // MemberRegisterService 생성자를 호출할 때 memberDao() 메서드를 호출.
        // 즉, memberDao()가 생성한 객체를 MemberRegisterService 생성자를 통해 주입
	}
	
	@Bean
	public ChangePasswordService changePwdSvc() {
		ChangePasswordService pwdSvc = new ChangePasswordService();
		pwdSvc.setMemberDao(memberDao());
        // ChangePasswordService 타입의 빈을 설정
        // 세터를 이용해서 의존 객체를 주입
		return pwdSvc;
	}

```



- @Configuration

  스프링 설정 클래스를 의미
  이 애노테이션을 붙여야 스프링 설정 클래스로 사용할 수 있다.

- @Bean 

  해당 메서드가 생성한 객체를 스프링 빈이라고 설정

  위 코드의 세개의 메서드에 @Bean 애노테이션을 붙였는데 각각의 메서드마다 한 개의 빈 객체를 생성한다.

  이때 메서드 이름을 빈 객체의 이름으로 사용한다. 

  예를 들어 memberDao() 메서드를 이용해서 생성한 빈 객체는 "memberDao"라는 이름으로 스프링에 등록

- MemberRegisterService 생성자를 호출할 때 memberDao() 메서드를 호출한다. 즉 memberDao()가 생성한 객체를 MemberRegisterService 생성자를 통해 주입한다.

- 설정 클래스를 만들었다고 해서 끝난 것이 아니다. 객체를 생성하고 의존 객체를 주입하는 것은 스프링 컨테이너이므로 설정 클래스를 이용해서 컨테이너를 생성해야 한다.

  AnnotationConfigApplicationContext 클래스를 이용해서 스프링 컨테이너를 생성할 수 있다.

  - ApplicationContext ctx = new AnnotationConfigApplicationContext (AppCtx.class);

  - 컨테이너를 생성하면 getBean() 메서드를 이용해서 사용할 객체를 구할 수 있다. 다음은 getBean() 메서드의 사용 예를 보여주고 있다.

  - ```java
    // 컨테이너에서 이름이 memberRegSvc인 빈 객체를 구한다.
    MemberRegisterService regSvc = ctx.getBean("memberRegSvc", MemberRegisterService.class);
    ```

    스프링 컨테이너(ctx)로부터 이름이 "memberRegSvc"인 빈 객체를 구한다. 앞서 자바 설정을 보면 다음 코드처럼 이름이 "memberRegSvc"인 @Bean 메서드를 설정했다. 이 메서드는 MemberRegisterAService 객체에 생성자를 통해 memberDao를 주입한다. 따라서 위 코드에서 구한 MemberRegisterService 객체는 내부에서 memberDao 빈 객체를 사용한다.

    ```java
    @Bean
    public MemberDao memberDao() {
    	return new MemberDao();
    }
    
    @Bean
    public MemberRegisterService memberRegSvc() {
    	return new MemberRegisterService(memberDao());
    }
    ```

    



```java
package main;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import config.AppCtx;
import spring.ChangePasswordService;
import spring.DuplicateMemberException;
import spring.MemberInfoPrinter;
import spring.MemberListPrinter;
import spring.MemberNotFoundException;
import spring.MemberRegisterService;
import spring.RegisterRequest;
import spring.VersionPrinter;
import spring.WrongIdPasswordException;

public class MainForSpring {

	private static ApplicationContext ctx = null;
	
	public static void main(String[] args) throws IOException {
		ctx = new AnnotationConfigApplicationContext(AppCtx.class);
		
		BufferedReader reader = 
				new BufferedReader(new InputStreamReader(System.in));
		while (true) {
			System.out.println("명령어를 입력하세요:");
			String command = reader.readLine();
			if (command.equalsIgnoreCase("exit")) {
				System.out.println("종료합니다.");
				break;
			}
			if (command.startsWith("new ")) {
				processNewCommand(command.split(" "));
				continue;
			} else if (command.startsWith("change ")) {
				processChangeCommand(command.split(" "));
				continue;
			} else if (command.equals("list")) {
				processListCommand();
				continue;
			} else if (command.startsWith("info ")) {
				processInfoCommand(command.split(" "));
				continue;
			} else if (command.equals("version")) {
				processVersionCommand();
				continue;
			}
			printHelp();
		}
	}

	private static void processNewCommand(String[] arg) {
		if (arg.length != 5) {
			printHelp();
			return;
		}
		MemberRegisterService regSvc = 
				ctx.getBean("memberRegSvc", MemberRegisterService.class);
		RegisterRequest req = new RegisterRequest();
		req.setEmail(arg[1]);
		req.setName(arg[2]);
		req.setPassword(arg[3]);
		req.setConfirmPassword(arg[4]);
		
		if (!req.isPasswordEqualToConfirmPassword()) {
			System.out.println("암호와 확인이 일치하지 않습니다.\n");
			return;
		}
		try {
			regSvc.regist(req);
			System.out.println("등록했습니다.\n");
		} catch (DuplicateMemberException e) {
			System.out.println("이미 존재하는 이메일입니다.\n");
		}
	}

	private static void processChangeCommand(String[] arg) {
		if (arg.length != 4) {
			printHelp();
			return;
		}
		ChangePasswordService changePwdSvc = 
				ctx.getBean("changePwdSvc", ChangePasswordService.class);
		try {
			changePwdSvc.changePassword(arg[1], arg[2], arg[3]);
			System.out.println("암호를 변경했습니다.\n");
		} catch (MemberNotFoundException e) {
			System.out.println("존재하지 않는 이메일입니다.\n");
		} catch (WrongIdPasswordException e) {
			System.out.println("이메일과 암호가 일치하지 않습니다.\n");
		}
	}

	private static void printHelp() {
		System.out.println();
		System.out.println("잘못된 명령입니다. 아래 명령어 사용법을 확인하세요.");
		System.out.println("명령어 사용법:");
		System.out.println("new 이메일 이름 암호 암호확인");
		System.out.println("change 이메일 현재비번 변경비번");
		System.out.println();
	}

	private static void processListCommand() {
		MemberListPrinter listPrinter = 
				ctx.getBean("listPrinter", MemberListPrinter.class);
		listPrinter.printAll();
	}

	private static void processInfoCommand(String[] arg) {
		if (arg.length != 2) {
			printHelp();
			return;
		}
		MemberInfoPrinter infoPrinter = 
				ctx.getBean("infoPrinter", MemberInfoPrinter.class);
		infoPrinter.printMemberInfo(arg[1]);
	}
	
	private static void processVersionCommand() {
		VersionPrinter versionPrinter = 
				ctx.getBean("versionPrinter", VersionPrinter.class);
		versionPrinter.print();
	}

}
```

MainForSpring 클래스가 MainForAssembler 클래스와 다른 점은 Assembler 클래스 대신 스프링 컨테이너인 ApplicationContext를 사용했다는 것 뿐.



#### 	6-2. DI 방식 1: 생성자 방식

```java
package spring;

import java.time.LocalDateTime;

// 생성자를 통해 의존 객체를 주입 받음
public class MemberRegisterService {
	private MemberDao memberDao;

	// 생성자를 통해 의존 객체를 주입 받음
	public MemberRegisterService(MemberDao memberDao) {
		// 주입 받은 객체를 필드에 할당
		this.memberDao = memberDao;
	}

	public Long regist(RegisterRequest req) {
		// 주입 받은 의존 객체의 메서드를 사용
		Member member = memberDao.selectByEmail(req.getEmail());
		...
		memberDao.insert(newMember);
		return newMember.getId();
	}
}

```

생성자를 통해 의존 객체를 주입받아 필드(this.memberDao)에 할당했다.

스프링 자바 설정에서는 생성자를 이용해서 의존 객체를 주입하기 위해 해당 설정을 담은 메서드를 호출.

```java
@Bean
public MemberDao memberDao() {
	return new MemberDao();
}

@Bean
public MemberRegisterService memberRegSvc() {
	return new MemberRegisterService(memberDao());
}
```

생성자에 전달할 의존 객체가 두 개 이상이어도 동일한 방식으로 주입하면 된다. 생성자 파라미터가 두 개인 예제를 살펴보기 전에 예제를 실행하는데 필요한 코드를 추가하자. 추구할 코드는 MemberDao 클래스의 selectAll() 메서드이다. 아래 코드에서 굵게 표시한 부분을 추가한다.



```java
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class MemberDao {
 ... 생략
 public Collection<Member> selectAll() {
 	return map.values();
 }
}
```



```java
package spring;

public class MemberPrinter {

	public void print(Member member) {
		System.out.printf(
				"회원 정보: 아이디=%d, 이메일=%s, 이름=%s, 등록일=%tF\n", 
				member.getId(), member.getEmail(),
				member.getName(), member.getRegisterDateTime());
	}

}
```

생성자로 두개의 파라미터를 전달받는 클래스 작성.



```java
package spring;

import java.util.Collection;

public class MemberListPrinter {

	private MemberDao memberDao;
	private MemberPrinter printer;

	public MemberListPrinter(MemberDao memberDao, MemberPrinter printer) {// MemberDao객체와 MemberPrinter 객체를 전달받는다.
		this.memberDao = memberDao;
		this.printer = printer;
	}

	public void printAll() {
		Collection<Member> members = memberDao.selectAll();
		members.forEach(m -> printer.print(m));
	}

}

```



#### 	6-3. DI 방식 2: 세터 메서드 방식

#### 	6-4. 기본 데이터 타입 값 설정

7. #### @Configuration 설정 클래스의 @Bean 설정과 싱글톤

8. #### 두 개 이상의 설정 파일 사용하기

   #### 8-1. @Configuration 애노테이션, 빈, @Autowired 애노테이션

   #### 8-2. @Import 애노테이션 사용

9. ###  getBean() 메서드 사용

10. ### 주입 대상 객체를 모두 빈 객체로 설정해야 하나?
