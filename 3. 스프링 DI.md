# Chapter 3 스프링 DI

- 이 장에서 다룰 내용
  - 객체 의존과 의존 주입(DI)
  - 객체 조립
  - 스프링 DI 설정



1. **의존이란?**
   - DI는 'Dependency Injection'의 약자로 우리말로는 '의존 주입'이라고 번역한다.
   - 의존(dependency)이란 객체 간의 의존을 의미



ex) 회원가입 처리 기능

```java
package spring;

import java.time.LocalDateTime;

public class MemberRegisterService {
	private MemberDao memberDao;

	public void regist(RegisterRequest req) {
		// 이메일로 회원 데이터(Member) 조회
		Member member = memberDao.selectByEmail(req.getEmail());
		if (member != null) {
			// 같은 이메일을 가진 회원이 이미 존재하면 익셉션 발생
			throw new DuplicateMemberException("dup email " + req.getEmail());
		}
		// 같은 이메일을 가진 회원이 존재하지 않으면 DB에 삽입
		Member newMember = new Member(
				req.getEmail(), req.getPassword(), req.getName(), 
				LocalDateTime.now());
		memberDao.insert(newMember);
	}
}
```

-> 서로 다른 회원은 동일한 이메일 주소를 사용할 수 없다는 요구사항

이 제약사항을 처리하기 위해 MembeRegisterService 클래스는 MemberDao 객체의 selectByEmail() 메서드를 이용해서 동일한 이메일을 가진 회원 데이터가 존재하는지 확인한다.

만약 같은 이메일을 가진 회원 데이터가 존재한다면 위 코드처럼 익셉션을 발생시킨다.

같은 이메일을 가진 회원 데이터가 존재하지 않으면 회원 정보를 담은 Member 객체를 생성하고 MemberDao 객체의 insert() 메서드를 이용해서 DB에 회원 데이터를 삽입한다.



위 코드에서 눈여겨볼 점은 MemberRergisterServiece 클래스가 DB 처리를 위해 MemberDao 클래스의 메서드를 사용한다는 점. 회원 데이터가 존재하는지 확인하기 위해 MemberDao 객체의 selectByEmail() 메서드를 실행하고, 회원 데이터를 Db에 삽입하기위해 insert() 메서드를 실행



이렇게 한 클래스가 다른 클래스의 메서드를 실행할 때 이를 ***'의존'*** 한다고 표현한다. 앞서 코드에서는 "MemberRegisterService" 클래스가 MemberDao 클래스에 의존한다고 표현할 수 있다.



의존하는 대상이 있으면 그 대상을 구하는 방법이 필요하다. 가장 쉬운 방법은 의존 대상객체를 직접 생성하는 것이다. 앞서 살펴본 MemberRegisterService 클래스도 다음 코드처럼 의존 대상인 MemberDao의 객체를 직접 생성해서 필드에 할당했다.



의존하는 대상이 있으면 그 대상을 구하는 방법이 필요하다. 가장 쉬운 방법은 의존 대상 객체를 직접 생성하는 것이다. 앞서 살펴본 MemberRegisterService 클래스도 다음 코드처럼 의존 대상인 MemberDao의 객체를 직접 생성해서 필드에 할당했다.

```java
public class MemberRegisterService {
	// 의존 객체를 직접 생성
	private MemberDao memberDao = new MemberDao();
	...
}
```



MemberRegisterService 클래스에서 의존하는 MemberDao 객체를 직접 생성하기 때문에 MemberRegisterService 객체를 생성하는 순간에 MemberDao 객체도 함께 생성한다.

```java
// 의존하는 memberDao의 객체도 함께 생성
MemberRegisterService svc = new MemberRegisterService();
```

클래스 내부에서 직접 의존 객체를 생성하는 것이 쉽긴하지만 유지보수 관점에서 문제점을 유발할 수 있다. 이 방식 외에 의존 객체를 구하는 또 다른 방법은 DI와 서비스 로케이터가 있다.





2. DI를 통한 의존 처리
   - DI(Dependency Injection, 의존 주입)는 의존하는 객체를 직접 생성하는 대신 의존 객체를 전달받는 방식을 사용한다. 예를 ㄷ르어 앞서 의존 객체를 직접 생성한 MemberRegisterService 클래스에 DI 방식을 적용하면 아래 코드 처럼 구현할 수 있다.

```java
package spring;

import java.time.LocalDateTime;

public class MemberRegisterService {
	private MemberDao memberDao;

	public MemberRegisterService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}

	public Long regist(RegisterRequest req) {
		Member member = memberDao.selectByEmail(req.getEmail());
		if (member != null) {
			throw new DuplicateMemberException("dup email " + req.getEmail());
		}
		Member newMember = new Member(
				req.getEmail(), req.getPassword(), req.getName(), 
				LocalDateTime.now());
		memberDao.insert(newMember);
		return newMember.getId();
	}
}

```

바뀐 부분은

 ```
public MemberRegisterService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}
 ```

이 부분이다. 직접 의존 객체를 생성했던 코드와 달리 바뀐 코드는 의존 객체를 직접 생성하지 않는다. 대신 08 ~ 10행과 같이 생성자를 통해서 의존 객체를 전달받는다. 즉 생성자를 통해 MemberRegisterService가 의존(Dependency)하고 있는 MemberDao 객체를 주입받은 것이다. 의존 객체를 직접 구하지 않고 생성자를 통해서 전달받기 때문에 이 코드는 DI패턴을 따르고 있다.



DI를 적용한 결과 MemberRegisterService 클래스를 사용하는 코드는 다음과 같이 MemberRegisterService 객체를 생성할 때 생성자에 MemberDAo 객체를 전달해야 한다.

```java
MemberDao dao = new MemberDao();
// 의존 객체를 생성자를 통해 주입한다.
MemberRegisterService svc = new MemberRegisterService(dao);
```

직접 의존 객체를 생성하지 않고 굳이 생성자를 통해서 의존하는 객체를 주입하는 이유는? 객체 지향 설계에 대한기본적인 이해가 필요하다.  그 이유는 **변경의 유연함**이다.





3. DI와 의존 객체 변경의 유연함

   의존 객체를 직접 생성하는 방식은 필드나 생성자에서 new 연산자를 이용해서 객체를 생성한다.

   회원 등록 기능을 제공하는 MemberRegisterService 클래스에서 다음 코드처럼 의존 객체를 직접 생성할 수 있다. 

   ```java
   public class MemberRegisterService {
   	private MemberDao memberDao = new MemberDao();
   	...
   }
   ```

   회원의 암호 변경 기능을 제공하는 ChangePasswordService 클래스도 다음과 같이 의존 객체를 직접 생성

   ```java
   public class ChangePasswordService {
   	private MemberDao memberDao = new MemberDao();
   	...
   }
   ```

   MemberDao 클래스는 회원 데이터를 데이터베이스에 저장한다고 가정. 이 상태에서 회원 데이터의 빠른 조회를 위해 캐시를 적용해야 하는 상황이 발생. 그래서 MemberDao 클래스를 상속받은 CachedMemberDao 클래스를 만들었다.

   ```java
   public class CachedMemberDao extends MemberDao { 
   	...
   }
   ```



※ 캐시는 데이터 값을 복사해 놓는 임시 장소를 가리킨다. 보통 조회 속도 향상을 위해 캐시를 사용한다. 예를 들어 데이터베이스에서 데이터를 조회하는경우를 생각해보자. 데이터베이스에서 데이터를 읽어오는데 10 밀리초(1밀리 초는 0.001초)가 걸린다면 메모리에 있는 데이터를 접근할 때에는 1밀리초도 안걸릴 것이다. DB에 있는 데이터 중 자주 조회하는 데이터를 메모리를 사용하는 캐시에 보관하면 조회 속도를 향상시킬 수 있다.



​	캐시 기능을 적용한 CachedMemberDao를 사용하려면 MemberRegisterService 클래스와 ChangePasswordService 클래스의 코드를 아래와 같이 변경해주어야 한다.



```java
public class MemberRegisterService {
	private MemberDao memberDao = new MemberDao();
	...
}

public class ChangePasswordService {
	private MemberDao memberDao = new MemberDao();
	...
}
```

사용할 클래스 변경에 따른 소스 코드 변경

```java
public class MemberRegisterService {
	private MemberDao memberDao = new CachedMemberDao();
	...
}

public class ChangePasswordService {
	private MemberDao memberDao = new CachedMemberDao();
	...
}
```

만약 MemberDao 객체가 필요한 클래스가 세 개라면 세 클래스 모두 동일하게 소스 코드를 변경해야 한다.



동일한 상황에서 DI를 사용하면 수정할 코드가 줄어든다. 예를 들어 다음과 같이 생성자를 통해서 의존 객체를 주입 받도록 구현했다고 하자.

```java
public class MemberRegisterService {
	private MemberDao memberDao = new MemberDao();
	public MemberRegisterService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}
	...
}

public class ChangePasswordService {
	private MemberDao memberDao = new MemberDao();
	public ChangePasswordService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}
	...
}
```

두 클래스의 객체를 생성하는 코드는 다음과 같다

```java
MemberDao memberDao = new MemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

실제 객체를 생성하는 한 곳만 수정

```java
MemberDao memberDao = new CachedMemberDao();
MemberRegisterService regSvc = new MemberRegisterService(memberDao);
ChangePasswordService pwdSvc = new ChangePasswordService(memberDao);
```

Di를 사용하면 MemberDao 객체를 사용하는 클래스가 세개여도 변경할 곳은 의존 주입 대상이 되는 객체를 생성하는 코드 한 곳 뿐이다. 앞서 의존 객체를 직접 생성했던 방식에 비해 변경할 코드가 한 곳으로 집중되는 것을 알 수 있다.



5. 객체 조립기

   앞서 DI를 설명할 때 객체 생성에 사용할 클래스를 변경하기 위해 (그 객체를 사용하는 코드를 변경하지 않고) 객체를 주입하는 코드 한 곳만 변경하면 된다고 했다. 그렇다면 실제 객체를 생성하는 코드는 어디에 있을까? *쉽게 생각하면 다음과 같이 메인 메서드에서 객체를 생성하면 될 것 같다.*

   ```java
   public class Main {
   	public static void main(String[] args) {
   		MemberDao memberDao = new MemberDao();
   		MemberRegisterService regSvc = new MemberRegisterService(memberDao);
           ChangePasswordService pwdSvc = new ChangePasswordService();
           pwdSvc.SetMemberDao(memberDao);
           ... // regSvc와 pwdSvc를 사용하는 코드
   	}
   }
   ```

   main 메서드에서 의존 대상 객체를 생성하고 주입하는 방법이 나쁘진 않다. 이방법보다 좀 더 나은 방법은 객체를 생성하고 의존 객체를 주입해주는 클래스를 따로 작성하는 것. 의존 객체를 주입한다는 것은 서로 다른 두 객체를 조립한다고 생각할 수 있는데 이런 의미에서 이 클래스를 조립기하고도 표현한다.



예를 들어 앞서 작성했던 회원 가입이나 암호 변경 기능을 제공하는 클래스의 객체를 생성하고 의존 대상이 되는 객체를 주입해주는 조립기 클래스는 아래와 같이 작성할 수 있다. 다른 클래스와 쉽게 구분하기 위해 조립기 클래스를 "assembler"패키지에 위치 시켰다.

```java
package assembler;

import spring.ChangePasswordService;
import spring.MemberDao;
import spring.MemberRegisterService;

public class Assembler {

	private MemberDao memberDao;
	private MemberRegisterService regSvc;
	private ChangePasswordService pwdSvc;

	public Assembler() {
		memberDao = new MemberDao();
		regSvc = new MemberRegisterService(memberDao);
		pwdSvc = new ChangePasswordService();
		pwdSvc.setMemberDao(memberDao);
	}

	public MemberDao getMemberDao() {
		return memberDao;
	}

	public MemberRegisterService getMemberRegisterService() {
		return regSvc;
	}

	public ChangePasswordService getChangePasswordService() {
		return pwdSvc;
	}

}
```

* regSvc : MemberRegisterService(memberDao 필드) + pwdSvc : ChangePasswordService(memberDao 필드) => memberDao : MemberDao(map 필드)



Assembler 클래스를 사용하는 코드는 다음처럼 Assembler 객체를 생성한다. 그 다음에 get 메서드를 이용해서 필요한 객체를 구하고 그 객체를 사용한다.

```java
Assembler assembler = new Assembler();
ChangePasswordService changePwdSvc = assembler.getChangePasswordService();
changePwdSvc.changePassword("madvirus@madvirus.net", "1234", "newpwd");
```



MemberDao 클래스가 아니라 MemberDao 클래스를 상속받은 CachedMemberDao 클래스를 사용해야 한다면 Assembler에서 객체를 초기화하는 코드만 변경하면 된다.

```java
public Assembler() {
	memberDao = new CachedMemberDao();
	regSvc = new MemberRegisterService(memberDao);
	pwdSvc = new ChangePasswordService();
	pwdSvc.setMemberDao(memberDao);
}
```


예제

```java
package main;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import assembler.Assembler;
import spring.ChangePasswordService;
import spring.DuplicateMemberException;
import spring.MemberNotFoundException;
import spring.MemberRegisterService;
import spring.RegisterRequest;
import spring.WrongIdPasswordException;

public class MainForAssembler {

	public static void main(String[] args) throws IOException {
		BufferedReader reader = 
				new BufferedReader(new InputStreamReader(System.in));
		while (true) {
			System.out.println("명령어를 입력하세요:");
			String command = reader.readLine();
			if (command.equalsIgnoreCase("exit")) {
				System.out.println("종료합니다.");
				break;
			}
			if (command.startsWith("new ")) {
				processNewCommand(command.split(" "));
				continue;
			} else if (command.startsWith("change ")) {
				processChangeCommand(command.split(" "));
				continue;
			}
			printHelp();
		}
	}

	private static Assembler assembler = new Assembler();

	private static void processNewCommand(String[] arg) {
		if (arg.length != 5) {
			printHelp();
			return;
		}
		MemberRegisterService regSvc = assembler.getMemberRegisterService();
		RegisterRequest req = new RegisterRequest();
		req.setEmail(arg[1]);
		req.setName(arg[2]);
		req.setPassword(arg[3]);
		req.setConfirmPassword(arg[4]);
		
		if (!req.isPasswordEqualToConfirmPassword()) {
			System.out.println("암호와 확인이 일치하지 않습니다.\n");
			return;
		}
		try {
			regSvc.regist(req);
			System.out.println("등록했습니다.\n");
		} catch (DuplicateMemberException e) {
			System.out.println("이미 존재하는 이메일입니다.\n");
		}
	}

	private static void processChangeCommand(String[] arg) {
		if (arg.length != 4) {
			printHelp();
			return;
		}
		ChangePasswordService changePwdSvc = 
				assembler.getChangePasswordService();
		try {
			changePwdSvc.changePassword(arg[1], arg[2], arg[3]);
			System.out.println("암호를 변경했습니다.\n");
		} catch (MemberNotFoundException e) {
			System.out.println("존재하지 않는 이메일입니다.\n");
		} catch (WrongIdPasswordException e) {
			System.out.println("이메일과 암호가 일치하지 않습니다.\n");
		}
	}

	private static void printHelp() {
		System.out.println();
		System.out.println("잘못된 명령입니다. 아래 명령어 사용법을 확인하세요.");
		System.out.println("명령어 사용법:");
		System.out.println("new 이메일 이름 암호 암호확인");
		System.out.println("change 이메일 현재비번 변경비번");
		System.out.println();
	}
}
```

